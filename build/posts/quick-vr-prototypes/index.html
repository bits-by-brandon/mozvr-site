<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width">
    <title>Quick VR Mockups with Illustrator - MozVR
    </title>
    <link rel="alternate" href="http://mozvr.com/feed.xml" type="application/rss+xml" title="A virtual reality website about virtual reality websites">
    <link rel="stylesheet" href="http://code.cdn.mozilla.net/fonts/fira.css">
    <link href="http://fonts.googleapis.com/css?family=Montserrat:400,700" rel="stylesheet" type="text/css">
    <link href="http://fonts.googleapis.com/css?family=Open+Sans:400,300,300italic,400italic,600,600italic,700,700italic,800italic,800" rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="/css/global.css">
  </head>
  <body class="post-detail">
    <!-- Splash + Title-->
    <div style="background-image: url('post-splash-2.jpg'); background-size: cover; background-position: 50% 50%" class="height40 py0 white bg-darkblue2 relative">
      <div class="py2 white bg-darken5">
        <div class="container">
          <div class="table">
            <div class="table-cell"><a href="/"><img src="/images/logo-mozvr-fira-white.svg" alt="Mozilla" class="mxn1 mt1 w10"></a></div>
            <div class="table-cell full-width px3 nowrap"><a href="/downloads" class="px2 light rounded1 button hover-light uppercase header-link h5">Downloads</a><a href="/projects" class="px2 light rounded1 button hover-light uppercase header-link h5">Projects</a><a href="/posts" class="px2 light rounded1 button hover-light uppercase header-link h5">Blog</a></div>
            <div class="table-cell right-align nowrap mxn2 pl2"><a href="https://github.com/MozVR/" target="_blank" class="rounded4 button hover-light px2"><img src="/images/icon-github-white.svg" alt="Twitter" class="w2"></a><a href="https://twitter.com/hashtag/mozvr" target="_blank" class="rounded4 button hover-light px2"><img src="/images/icon-twitter-white.svg" alt="Twitter" class="w2"></a>
              <!--a(href='https://wiki.mozilla.org/IRC' target='_blank').rounded1.button.hover-light IRC-->
              <!--a(href='https://mail.mozilla.org/listinfo/web-vr-discuss' target='_blank').rounded1.button.hover-light Mailing List-->
            </div>
          </div>
        </div>
      </div>
      <div class="absolute bottom-2 full-width">
        <div class="container">
          <div class="clearfix">
            <div class="col col-12 m-col-8">
              <h1 class="post-title italic ultralight uppercase mxn3 f-huge"><span class="p2 bg-yellow black">Quick VR Mockups with Illustrator</span></h1>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div class="py3 gray8 bg-white">
      <div class="container">
        <!--Author-->
        <div class="table mt3">
          <div class="table-cell col-1 pr1"><a href="http://twitter.com/@joshcarpenter" target="_blank" class="hover-lighten"><img src="/people/josh-3.png" class="circle fit w4"></a></div>
          <div class="table-cell col-11 gray5 light"> By  <a href="http://twitter.com/@joshcarpenter" target="_blank" class="basiclink-blue regular">Josh Carpenter</a> • <span class="italic">Tuesday Dec 09, 2014</span></div>
        </div>
        <!--Body-->
        <div class="clearfix">
          <div class="post col col-12 m-col-8">
            <!--p.regular.h2.py3.black.m0
            = page.metadata.intro
            
            -->
            <!--.bt1.b-dotted.b-gray3.mb3--><p class="intro h2">Designing for the <span class="caps">VR</span> web is nothing like designing for the desktop and mobile web. Every process and principle must be rethought, including how we prototype our ideas. With a simple cylinder and some precise measurements, however, we can move rapidly between our favorite 2D design apps and the virtual canvas of our&nbsp;headsets.</p>

<p>After years of bouncing between Photoshop and Keynote I’ve happily settled on Illustrator as my primary interface design tool. I’m good with 3D apps like Cinema 4D, but for all their power, they’re painful to use for typography, interface layout, etc. So when it came time to design a <span class="caps">VR</span> web navigation UI, I wanted a workflow that let me rapidly iterate from mockups created in Illustrator to wrap-around WebVR test&nbsp;scenes.</p>
<div class="post-summary">
  <h2>In&nbsp;Brief</h2>
  <ol>
    <li>Create your layout in a 2D design app and export as a&nbsp;bitmap.</li>
    <li>Create cylinder mesh in three.js with a circumference/height ratio that matches the width/height ratio of the&nbsp;bitmap.</li>
    <li>Apply the bitmap as a texture to the cylinder and flip the cylinder&nbsp;faces.</li>
    <li>View in&nbsp;<span class="caps">VR</span>!</li>
  </ol>
  <a href="http://mozvr.github.io/vr-web-examples/mockups-on-cylinders/" class="assets-link" target="_blank">
    <div class="table">
      <div class="table-cell">
        View Demo
      </div>
      <div class="table-cell">
        <img src="/images/icon-goggles-2-white.svg" class="left w3">
      </div>
    </div>
  </a>
  <a href="/posts/quick-vr-prototypes/webvr-illustrator-template.zip" class="assets-link">
    <div class="table">
      <div class="table-cell">
        Get the files
      </div>
      <div class="table-cell">
        <img src="/images/icon-download-2-white.svg" class="left w3">
      </div>
    </div>
  </a>
</div>

<p>We start in our preferred 2D design app. In my case, Illustrator. We create a canvas that is <strong>360cm x 90cm</strong>. When later viewed in the Rift, this canvas will wrap around us, mapped onto a cylinder which we (or the WebGL camera, more accurately) are in the center of. Like the&nbsp;following:</p>
<figure>
  <img src="mockup1.png" alt="Top: our Illustrator layout. Bottom: our layout mapped ontp a WebGL cylinder.">
  <figcaption>
    Our 360x90cm Illustrator layout will be mapped onto a WebGL cylinder with a 360cm circumference and 90cm height.
  </figcaption>
</figure>

<p>Working with real world units is important because sense of scale is integral to virtual reality, and the scale your users will perceive will be determined primarily by size of the elements in your scene relative to the distance between the user’s eyes. A distance which is defined in real world measurements (meters, to be precise). Working in real world units throughout our pipeline ensures we don’t encounter any weird surprises, like text blocks that suddenly appear 10 stories tall (unless of course you <em>want</em> that). <!--That measurement is the referred as the interpupilary distance, and it is 60mm on average in adults. The Rift reports this to the browser as 0.064 meters. by the . A VR HMD is displaying a different image to each eye,  rendering of virtual reality creates the perception of genuine scale. Your eyes can perceive the difference between a virtual cup a table versus a mountain miles away.--></p>
<p>As we create our layouts, it’s also important that we know where on the cylinder our elements will eventually appear. That’s why a 360cm width is convenient: each centimeter on the horizontal of our composition will equal one degree on the circumference of the 3D cylinder. The center of our layout (180cm/180°) will appear directly in front of the viewer, while the left and right edges will appear behind&nbsp;them.</p>
<figure>
  <img src="mockup2.png" alt="Top: our Illustrator layout. Bottom: our layout mapped ontp a WebGL cylinder.">
</figure>

<p>But wait! How much of our layout will be visible to the user? Human field of view is <a href="http://xkcd.com/1080/">limited</a>, after all. We wouldn’t want to make our users turn their heads 90° to read an important status indicator. The following diagram from Extron gives us some idea of what we have to work&nbsp;with.</p>
<figure>
  <img src="human-visual-field.jpg" alt="Diagram of human visual field. Source: Extron.">
  <figcaption>
    Human field of vision is approximately 180° horizontal, but our ability to read text is limited to just the center 10°, and our ability to perceive symbols to the center 60°.
  </figcaption>
</figure>

<p>To help us keep track of what our users can see, it’s helpful to set up a few guides in our layout template that express these values. Most importantly, the center 60°, 30° and 10° of our vision, within which we can see color, shape and text,&nbsp;respectively.</p>
<figure>
  <img src="mockup3.png" alt="Mockup of a 360x90cm layout template with overlays for important field of view measurements.">
</figure>

<p>We also need to remember that current <span class="caps">VR</span> headsets have a fairly limited field of view. The DK2, for example, has an effective horizontal field of view of approximately 90°. This crops what we can see in the headset (without turning our heads) to the&nbsp;following:</p>
<figure>
  <img src="visual-field-DK2.png" alt="Diagram of Oculus Rift DK2 field of veiw. Source: Extron.">
</figure>

<p>Once we have a layout ready, we want to export it as a bitmap. We can scale at export-time as much as we need, so long as we do not change the same layout’s width/height&nbsp;ratio. </p>
<h2 id="viewing-our-layout-in-vr">Viewing our layout in&nbsp;<span class="caps">VR</span></h2>
<p>The good news is we don’t need much <span class="caps">JS</span> to create our WebGL VR scene. The following scene is built on the MozVR three.js WebVR boilerplate, available from our <a href="https://github.com/MozVR/vr-web-examples">vr-web-examples repo</a>. It uses <a href="https://github.com/mrdoob/three.js">three.js</a> and two extra libraries that handle detecting, communicating and rendering to an attached <span class="caps">VR</span>&nbsp;headset.</p>
<p>To preview our mockup, we simply copy the bitmap we saved into the <code>/images</code> directory and rename it <code>mockup.png</code>, overwriting the existing file. We then load <code>index.html</code> into our <span class="caps">VR</span>-enabled browser (like <a href="http://mozvr.com/downloads">Firefox with <span class="caps">VR</span></a>), and enter <span class="caps">VR</span> mode by pressing <code>F</code> or double-clicking. In our headset the scene the browser should render our scene, and we should see our layout wrapped around us on a&nbsp;cylinder.</p>
<h3 id="the-code">The&nbsp;code</h3>
<p>Let’s look at <code>index.html</code> to see how this works. Most of the code is standard boilerplate for a three.js scene with <span class="caps">VR</span> support. To add our layouts, we need&nbsp;to: </p>
<ol>
<li>Create a cylinder geometry with a circumference/height ratio that matches the width/height ratio of the&nbsp;bitmap.</li>
<li>Create a material and load our mockup as a&nbsp;texture</li>
<li>Flip the cylinder geometry to ensure the mockup displays correctly (facing&nbsp;“inwards”)</li>
<li>Create a mesh from our geometry and material and add it to the scene so it&nbsp;renders.</li>
</ol>
<p>To do this we first set up a few variables for our cylinder&nbsp;geometry:</p>
<pre><code class="lang-javascript"><span class="comment">/*
Set up the key measurements of the cylinder that will display our mockup image. It is important to match these measurements to the size of the image, or the surface area of the cylinder will be different from the image, causing it to appear squished or stretched. We start with the circumference of the cylinder. Set it to match the width of the image. Remember that the standard unit of measurement for <span class="caps">VR</span> scenes is meters. If our mockup canvas is 360 centimeters wide, for example, we set the circumference value to be 3.6 (360/100).
*/</span>

<span class="keyword">var</span> circumference = <span class="number">3.6</span>;

<span class="comment">/*
Set up the radius of the cylinder. We derive the radius from the circumference.
*/</span>

<span class="keyword">var</span> radius = circumference / <span class="number">3.14</span> / <span class="number">2</span>;

<span class="comment">/*
Set up the height of the cylinder. As with the circumference, we match this value to the height of our mockup, and convert to meters (from 90cm to 0.9 meters)
*/</span>

<span class="keyword">var</span> height = <span class="number">0.9</span>;
</code></pre>
<p>We then create a cylinder geometry instance using the variables, and invert it’s&nbsp;faces:</p>
<pre><code class="lang-javascript"><span class="comment">/*
Create the geometry for the cylinder object that will display our mockups.
The cylinder constructor takes the following arguments: CylinderGeometry(radiusTop, radiusBottom, height, radiusSegments, heightSegments, openEnded). We add 60 radiusSegments to make the cylinder smooth, and leave the top and bottom openEnded.
*/</span>

<span class="keyword">var</span> geometry = <span class="keyword">new</span> <span class="caps">THREE</span>.CylinderGeometry( radius, radius, height, <span class="number">60</span>, <span class="number">1</span>, <span class="literal">true</span> );

<span class="comment">/*
Invert the scale of the geometry on the X axis. This flips the faces of the cylinder so they faces inwards, which has the visible effect of displaying the mockups as we expect: facing inwards and in the correct orientation. Try removing this line to see what happens without flipping the scale.
*/</span>

geometry.applyMatrix( <span class="keyword">new</span> <span class="caps">THREE</span>.Matrix4().makeScale( -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span> ) );
</code></pre>
<p>We then create a material for our&nbsp;mesh:</p>
<pre><code class="lang-javascript"><span class="comment">/*
Create the material that we will load our mockup into and apply to our cylinder object. We set `transparent` to true, enabling us to optionally use mockups with alpha channels. We set `side` to <span class="caps">THREE</span>.DoubleSide, so our material renders facing both inwards and outwards (relative to the  direction of the faces of the cylinder object). By default, materials and the faces of three.js meshes face outwards and are invisible from the reverse. Setting THREE.DoubleSide ensures the cylinder and it's material will be visible no matter which direction (inside or out) we are viewing it from. This step is not strictly necessary, since we are actually going to invert the faces of the object to face inwards in a later step, but it is good to be aware of the `side` material attribute and how to define it. We then load our mockup as a texture.
*/</span>

<span class="keyword">var</span> material = <span class="keyword">new</span> <span class="caps">THREE</span>.MeshBasicMaterial( { 
  transparent: <span class="literal">true</span>, 
  side: <span class="caps">THREE</span>.DoubleSide,
  map: THREE.ImageUtils.loadTexture( <span class="string">'images/mockup.png'</span> )
});
</code></pre>
<p>Next, we create the mesh and add it to our&nbsp;scene:</p>
<pre><code class="lang-javascript"><span class="comment">/*
Create the mesh of our cylinder object from the geometry and material.
*/</span>

<span class="keyword">var</span> mesh = <span class="keyword">new</span> <span class="caps">THREE</span>.Mesh( geometry, material );

<span class="comment">/*
Add our cylinder object to the scene. The default position of elements added to a three.js scene is 0,0,0, which is also the default position of our scene's camera. So our camera sits inside our cylinder.
*/</span>

scene.add( mesh );
</code></pre>
<p>0ur cylinder should now render in the scene, with us positioned at it’s&nbsp;center.</p>
<h2 id="experimenting-further">Experimenting&nbsp;further</h2>
<p>With our layout loaded, there’s lots more we can optionally&nbsp;do.</p>
<h3 id="1-change-the-radius-of-our-cylinder">1. Change the radius of our&nbsp;cylinder</h3>
<p>This has the effect of bringing the mockup closer or further from the user. By default, a cylinder with a circumference of 3.6m has a radius of 0.573 meters (22.5 inches). This is about the average distance that most of us view our desktop or laptop displays from. Using your <span class="caps">VR</span> headset, you can adjust the mesh scale to see what feels right for your layout. Make sure to set the same value for the X,Y and Z, or the cylinder will be&nbsp;stretched.</p>
<pre><code class="lang-javascript"><span class="comment">/*
To adjust the distance between our mockups and the user, we can optionally scale our mesh. If we apply 0.5 to the X,Y,Z, for example, the radius shrinks by half, and the mockups become twice as close to our eyes. Because we are scaling proportionally (equal on X,Y,Z) the mockups do not _appear_ any larger, but the stereo effect of the <span class="caps">VR</span> headset tells us they are closer. Play with this setting to find a value that you like.
*/</span>

mesh.scale.set( <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span> );
</code></pre>
<p>As you experiment, also consider the potential for other objects in your scene to come between your layout and the user. If I design a heads up display-style navigation interface with a 0.5 meter radius, for example, and my avatar in the <span class="caps">VR</span> world walks up to a wall, the geometry of the wall is probably going to come closer than the interface, thereby occluding it. My loading indicator suddenly disappearing into&nbsp;brick.</p>
<p>The <a href="http://static.oculus.com/sdk-downloads/documents/Oculus_Best_Practices_Guide.pdf">Oculus Best Practices Guide</a> (which is required reading for any creator of <span class="caps">VR</span> content) suggests the&nbsp;following:</p>
<blockquote>
<p>“Bringing UIs in closer (eg 20cm) can help prevent occlusion (where in-world objects come closer to the user than <span class="caps">HUD</span> objects), but require the user to “…shift their focus between the close-up HUD and the much more distant scene whenever they check the HUD. These kinds of shifts in eye convergence and accommodation (eye lens focus) can quickly lead to fatigue and&nbsp;eyestrain.”</p>
</blockquote>
<h3 id="2-add-a-background-image">2. Add a background&nbsp;image</h3>
<p>By default the background of our scene is black, but it’s easy to add a background&nbsp;image.</p>
<pre><code class="lang-javascript"><span class="comment">/*
To optionally add a background image to the scene, create a large sphere and apply a bitmap to it. First, create the geometry for the sphere. The SphereGeometry constructor takes several arguments, but we only need the basic three: radius, widthSegments, and heightSegments. We set radius to a big 5000 meters so the sphere is less likely to occlude other objects in our scene. We set width and height segments to 64 and 32 respectively to make it sphere surface smooth. And we then invert the geometry on the x-axis using <span class="caps">THREE</span>.Matrix4().makeScale(), to flip the geometry faces so they face "inwards", as we did with the mockup cylinder.
*/</span>

<span class="keyword">var</span> geometry = <span class="keyword">new</span> <span class="caps">THREE</span>.SphereGeometry( <span class="number">5000</span>, <span class="number">64</span>, <span class="number">32</span> );
geometry.applyMatrix( <span class="keyword">new</span> <span class="caps">THREE</span>.Matrix4().makeScale( -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span> ) );

<span class="comment">/*
Create the material we will load our background image into.
*/</span>

<span class="keyword">var</span> material = <span class="keyword">new</span> <span class="caps">THREE</span>.MeshBasicMaterial( {
  map: THREE.ImageUtils.loadTexture( <span class="string">'images/background.png'</span> )
} );

<span class="comment">/*
Create the mesh of our background from the geometry and material, and add it to the scene.
*/</span>

<span class="keyword">var</span> mesh = <span class="keyword">new</span> <span class="caps">THREE</span>.Mesh( geometry, material );
scene.add( mesh );
</code></pre>
<p>And that’s it! When we load the scene and put on our headset, we should by standing inside our mockup layout, with a distant background image wrapping&nbsp;everything.</p>
<p>Play around with different background images to find one that gives you the contrast you want. I tend to use something that approximates the look of my final 3D scene, so I can judge colors, legibility, etc. For best results use panoramic images in equirectangular format, like the following. They will map perfectly (without distortion) to the WebGL&nbsp;sphere:</p>
<figure>
  <img src="puydesancy.jpg" alt="Equirectangular panorama photo of mountain top in France by Alexandre Duret-Lutz">
  <figcaption>
    An example of an equirectangular image, taken by Alexandre Duret-Lutz. Find more of Alexandre’s beautiful panos on <a href="https://www.flickr.com/photos/gadl/" target="_blank">Flickr</a>.
  </figcaption>
</figure>

<p>Flickr’s <a href="https://www.flickr.com/groups/equirectangular/">Equirectangular Pool</a> is a fantastic source for images (just be sure to check the licenses). You can also use 3D apps to render 3D scenes into equirectangular format. I used Cinema 4D + Vray to create the blurred pano used in this tutorial, for example. Or if you need just a simple gradient or solid color, use your favorite image editing app to fill a canvas with 2:1 width:height&nbsp;proportions.</p>
<h3 id="3-create-multiple-layers-at-different-depths">3. Create multiple layers at different&nbsp;depths</h3>
<p>Depth is a fundamental element of design for virtual reality. Through the two separate eyes of a <span class="caps">VR</span> headset we can perceive even slight differences in z-position between elements. We can see that a glowing button hovers 0.5cm above the surface of it’s parent dialogue, for example, or that a UI stretches off into the horizon. Depth in VR does naturally what drop shadows do skeumorphically in 2D layouts: create visual contrast between stacked&nbsp;layers.</p>
<p>Adding additional layers to our scene is easy. We create additional meshes and load a different bitmaps into their&nbsp;materials.</p>
<ul>
<li>Copy and paste the code above, not including the variables for circumference, radius, and height (they only need to be specified&nbsp;once).</li>
<li>In the new material, specify a different bitmap, eg <code>THREE.ImageUtils.loadTexture( &#39;images/mockup-background.png&#39; )</code></li>
<li>Tweak the mesh scale values to push the layout closer or further, as desired. This creates separation between&nbsp;layers.</li>
</ul>
<p>My tactic in creating the Mozvr.com layout was to start by building my layouts in a single Illustrator layer without thinking too much about 3D composition, and then group the elements into new layers towards the end of the process, with each layer representing a different depth. I then saved each layer individually as a bitmap with transparency. Each of these I then loaded into it’s own cylinder mesh, which I then tweaked the scale of to find the desired separations. I found quickly that Depth is particularly spectacular when combined with the <span class="caps">DK2</span>’s 3D camera, which enables us to instantly perceive the parallax effect between layers as we lean our bodies around inside the virtual&nbsp;world.</p>
<h2 id="have-fun-">Have&nbsp;fun!</h2>
<p>This technique enables us to bridge the workflows we know with the new world of virtual reality. It’s a quick a simple way to iterate rapidly. Start hacking and have&nbsp;fun!</p>
<!--## TODO

* Add screenshots of progress and result to code section
* Create assets download section
  - Firefox with VR
  - Illustrator template (save as Illustrator 8 to ensure accessibility)
  - three.js & VR libs (latest)
  - Code (final scene)
* Create GIF of user leaning in to HIRO, showing depth effect
* Link to end result (open in VR mode)
-->


          </div>
          <div class="col m-col-2"></div>
        </div>
        <!--Author-->
        <div class="b-solid b-blue0 bt4 mt4 mb0"></div>
        <div class="clearfix mb3">
          <h5 class="gray5 mb3">About the author</h5>
                    <div class="col col-2"><a href="http://www.twitter.com/joshcarpenter" target="_blank"><img src="/people/josh-3.png" class="fit rounded1 outline-white"></a></div>
                    <div class="col col-10 m-col-6 px2">
                      <h3 class="m0">Josh Carpenter
                      </h3>
                      <p>VR Researcher, Mozilla<br><a href="http://www.twitter.com/joshcarpenter" class="basiclink-blue">@joshcarpenter</a>
                        <p class="semibold"></p>Josh works full time on the UX of WebVR. His background is in motion graphics, visual design and architectural visualization, and he was previously UX Lead of Firefox OS.
                      </p>
                    </div>
        </div>
      </div>
    </div>
    <!-- Footer-->
    <div class="py3 bg-blue3 light">
      <div class="container">
        <div class="clearfix">
          <div class="col col-12 m-col-8"><a href="https://www.mozilla.org/en-US/" target="_blank"><img src="/images/logo-mozilla-white.svg" alt="Mozilla" class="w6 mt3 mb2"></a>
            <p class="h5"><a href="https://www.mozilla.org/en-US/privacy/websites/" target="_blank" class="pr2 blue0">Privacy Policy</a><a href="https://www.mozilla.org/en-US/about/legal/" target="_blank" class="pr2 blue0">Legal Notices</a><a href="https://www.mozilla.org/en-US/about/legal/fraud-report/" target="_blank" class="pr2 blue0">Report Trademark Abuse</a></p>
            <p class="h6 blue1">Except where otherwise noted, content on this site is licensed under the<a href="http://creativecommons.org/licenses/by-sa/2.5/" target="_blank" class="blue1">Creative Commons Attribution Share-Alike License v3.0</a>or any later version. Site built with<a href="http://wintersmith.io/" target="_blank" class="blue1">Wintersmith</a>.</p>
          </div>
          <div class="col m-col-4"></div>
        </div>
      </div>
    </div>
  </body>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    
    ga('create', 'UA-24056643-3', 'auto');
    ga('send', 'pageview');
  </script>
</html>
